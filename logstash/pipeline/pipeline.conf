input {
  # Direct file input from ModSecurity logs
  file {
    path => "/var/log/modsecurity/modsec_audit.json"
    start_position => "beginning"
    codec => "json"
    add_field => { 
      "source" => "modsecurity"
      "track" => "analytics"
    }
  }
  
  # Keep Kafka input as backup
  kafka {
    #bootstrap_servers => "kafka:9092"
    bootstrap_servers => "kafka.waf-processing.svc.cluster.local:9092"
    topics            => ["waf-logs"]
    group_id          => "ls-waf-analytics"
    auto_offset_reset => "earliest"
    codec             => "json"
    decorate_events   => true
  }
}

filter {
  # Process ModSecurity JSON logs directly
  if [source] == "modsecurity" and [transaction] {
    mutate {
      add_tag => [ "modsecurity_direct", "analytics_track" ]
      # Extract key fields from ModSecurity transaction structure
      add_field => {
        "[client][ip]" => "%{[transaction][client_ip]}"
        "[event][original_timestamp]" => "%{[transaction][time_stamp]}"
        "[http][request][method]" => "%{[transaction][request][method]}"
        "[url][path]" => "%{[transaction][request][uri]}"
        "[http][response][status_code]" => "%{[transaction][response][http_code]}"
        "[event][category]" => "web"
        "[event][type]" => "access"
        "[event][dataset]" => "waf.modsecurity"
        "[labels][track]" => "analytics"
      }
    }

    # Parse ModSecurity timestamp
    date {
      match => ["[transaction][time_stamp]", "EEE MMM dd HH:mm:ss yyyy", "EEE MMM  d HH:mm:ss yyyy"]
      target => "@timestamp"
      timezone => "UTC"
    }

    # Extract attack information from messages
    if [transaction][messages] {
      ruby {
        code => '
          messages = event.get("[transaction][messages]")
          if messages && messages.is_a?(Array) && !messages.empty?
            # Extract rule IDs and severity
            rule_ids = messages.map { |msg| msg.dig("details", "ruleId") }.compact
            severities = messages.map { |msg| msg.dig("details", "severity") }.compact.map(&:to_i)
            
            event.set("[modsecurity][rules]", rule_ids)
            event.set("[modsecurity][max_severity]", severities.max || 0) if !severities.empty?
            event.set("[modsecurity][rule_count]", rule_ids.length)
            
            # Classify attack type based on rule IDs
            attack_type = "other"
            rule_ids.each do |rule_id|
              case rule_id.to_s
              when /^94[0-9]/  # XSS rules
                attack_type = "xss"
                break
              when /^94[12]/  # SQL injection rules  
                attack_type = "sqli"
                break
              when /^93[0-9]/  # LFI/Path traversal
                attack_type = "lfi"
                break
              when /^913/     # Scanner detection
                attack_type = "scanner"
                break
              when /^932/     # RCE
                attack_type = "rce"
                break
              end
            end
            event.set("[modsecurity][attack_type]", attack_type)
          end
        '
      }
    }

    # GeoIP enrichment for client IP
    if [client][ip] and [client][ip] !~ /^(127\.|10\.|172\.(1[6-9]|2\d|3[01])\.|192\.168\.)/ {
      geoip {
        source => "[client][ip]"
        target => "[client][geo]"
      }
    }

    # Clean up original transaction field to reduce storage
    mutate {
      remove_field => ["transaction"]
    }
  }

  # Process ksqlDB/Kafka input format (legacy)
  if [@metadata][kafka][topic] == "waf-logs" {
    mutate {
      add_tag => [ "kafka_input", "analytics_track" ]
      rename => { "CLIENT_IP" => "[client][ip]" }
      rename => { "TS" => "[event][original_timestamp]" }
      rename => { "METHOD" => "[http][request][method]" }
      rename => { "URI" => "[url][path]" }
      rename => { "STATUS" => "[http][response][status_code]" }
      rename => { "CLASSIFICATION_TRACK" => "[labels][track]" }
    }
  }

  # Common cleanup
  mutate {
    remove_field => ["@version", "source", "host"]
  }
}

output {
  # All analytics data to Elasticsearch
  if "analytics_track" in [tags] {
    elasticsearch {
      #hosts => ["http://waf-es:9200"]
      hosts => ["http://elasticsearch.waf-data.svc.cluster.local:9200"]
      index => "waf-logs-%{+YYYY.MM.dd}"
      ilm_enabled => false
    }
  }
  
  # Debug output to see what's being processed
  if "modsecurity_direct" in [tags] {
    stdout { 
      codec => rubydebug {
        metadata => false
      }
    }
  }
}